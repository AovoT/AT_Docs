<h2 id="T5Pbc">内容概览</h2>
+ 用 **g++ 一条命令**把一堆 `.cpp` 直接编成可执行文件
+ 认识 **编译四阶段**（预处理 → 编译 → 汇编 → 链接）与中间文件后缀
+ 写出 **现代 CMake** 的最小可用模板（含静态/动态库）
+ 解决遇到的 **链接与库路径**问题

---

<h2 id="KeBWm">1. 编译四阶段</h2>
1. **预处理**：展开 `#include/#define`、移除注释  
    - 常见后缀：C++ 用 `.ii`（C 常用 `.i`）  
    - 命令：`g++ -E main.cpp -o main.ii`
2. **编译**（到汇编）：C++ → 汇编  
    - 后缀：`.s`  
    - 命令：`g++ -S main.ii -o main.s`
3. **汇编**（到目标文件）：汇编 → 机器码  
    - 后缀：`.o`（GCC/Clang），`.obj`（MSVC）  
    - 命令：`g++ -c main.s -o main.o`
4. **链接**：把所有 `.o` 与库合起来 → **可执行文件**  
    - Linux/Mac 常见输出名为 `a.out`（若未 `-o` 指定）  
    - 命令：`g++ main.o foo.o bar.o -o my_program`

---

<h2 id="S0e05">2. g++ 常用选项速查</h2>
+ 头文件目录：`-Iinclude`
+ 库目录：`-Lbuild`
+ 链接库：`-lmylib -lopencv_core`（不写 `lib` 前缀与 `.so/.a` 后缀）
+ 多线程：`-pthread`
+ 调试/优化：`-g -O2 -DNDEBUG`
+ 警告：`-Wall -Wextra -Wpedantic`
+ 运行时查找动态库：`-Wl,-rpath,'$ORIGIN'`（可执行文件同目录）

**示例：链接 pthread 与 OpenCV**

```bash
g++ src/*.cpp -Iinclude -O2 -Wall -Wextra -pthread \
    `pkg-config --cflags --libs opencv4` \
    -o build/app
```

---

<h2 id="Toiby">3. 用 CMake 构建</h2>
<h3 id="rzvsm">推荐的最小结构</h3>
```plain
demo/
├─ CMakeLists.txt
├─ include/
│   └─ mylib/math.hpp
├─ lib/
│   ├─ CMakeLists.txt
│   └─ math.cpp
└─ src/
    └─ main.cpp
```

<h3 id="kWxsx">顶层 CMakeLists.txt（可直接用）</h3>
```cmake
cmake_minimum_required(VERSION 3.17)
project(demo LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)  # 方便 clangd/IDE

if (NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release)
endif()

add_subdirectory(lib)

add_executable(${PROJECT_NAME} src/main.cpp)
target_link_libraries(${PROJECT_NAME} PRIVATE mylib)

# 第三方库 (不多说了，后面自己整，这个文档不会多涉及第三方库的导入)
# find_package(OpenCV REQUIRED)
# target_link_libraries(${PROJECT_NAME} PRIVATE ${OpenCV_LIBS}})
```

<h3 id="TqS1Z">lib/CMakeLists.txt（把公共代码做成库）</h3>
```cmake
project(mylib)
add_library(${PROJECT_NAME}STATIC)  # 或 SHARED
target_sources(${PROJECT_NAME}
  PRIVATE
    math.cpp
  PUBLIC
    ${CMAKE_SOURCE_DIR}/include/mylib/math.hpp
)

target_include_directories(mylib
  PUBLIC
    ${CMAKE_SOURCE_DIR}/include
)

```

<h3 id="aHxuv">构建命令</h3>
```bash
# Linux
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
```

> **提示**：
>
> + `file(GLOB_RECURSE ... CONFIGURE_DEPENDS src/*.cpp)` 能自动收集源码
> + `target_include_directories` 的作用域：
>     - `PRIVATE`：仅当前目标使用
>     - `PUBLIC`：当前目标 + 链接它的目标都会继承
>     - `INTERFACE`：当前目标不用，**但**链接它的目标会用（常见于头文件库）
>

---

<h2 id="dgx1p">4. 把库拆出来（静态/动态）</h2>
**静态库**（`.a/.lib`，链接进可执行，发布时无需再带库）

```cmake
add_library(mylib STATIC math.cpp)
target_include_directories(mylib PUBLIC ${CMAKE_SOURCE_DIR}/include)
```

**动态库**（`.so/.dll/.dylib`，运行时加载，需要能被系统找到）

```cmake
add_library(mylib SHARED math.cpp)
target_include_directories(mylib PUBLIC ${CMAKE_SOURCE_DIR}/include)

# 运行时搜索路径（Linux）
set_target_properties(${PROJECT_NAME} PROPERTIES
  INSTALL_RPATH "$ORIGIN"
  BUILD_RPATH "$ORIGIN"
)
```

---

<h2 id="ePULP">5. 最小可运行样例</h2>
**include/add.h**

```cpp
#pragma once
int add(int a, int b);
```

**src/add.cpp**

```cpp
#include "add.h"
int add(int a, int b) { return a + b; }
```

**src/main.cpp**

```cpp
#include <iostream>
#include "add.h"
int main() {
  std::cout << "3 + 4 = " << add(3, 4) << std::endl;
  return 0;
}
```

**（A）直接用 g++：**

```bash
g++ src/*.cpp -Iinclude -O2 -Wall -Wextra -o build/app
./build/app
# 输出：3 + 4 = 7
```

**（B）用 CMake：**（顶层 CMakeLists.txt）

```cmake
cmake_minimum_required(VERSION 3.17)
project(demo LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
file(GLOB_RECURSE SRC CONFIGURE_DEPENDS src/*.cpp)
add_executable(${PROJECT_NAME} ${SRC})
target_include_directories(${PROJECT_NAME} PRIVATE include)
```

```bash
cmake -B build  -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
./build/demo
```

---

<h2 id="fWCgr">6. 常见错误</h2>
+ **undefined reference（未定义引用）**
    - 忘了把某些 `.o` 或库一起链接；或库**顺序**不对（库应放在依赖它的对象**后面**）。
+ **multiple definition（重复定义）**
    - 在头文件里放了非 `inline` 的函数**定义**（应只放声明）；或全局变量未 `extern`。
    - 解决：头文件放声明，源文件放定义；或 `inline`/`constexpr`。
+ **cannot find -lxxx（找不到库）**
    - 库名或路径不对：检查 `-L` 与实际文件名 `libxxx.so/a` 是否存在。
    - Linux 运行时找不到 `.so`：加 `-Wl,-rpath,'$ORIGIN'` 或设置 `LD_LIBRARY_PATH`。
+ **file format not recognized（格式不识别）**
    - 把 `.cpp/.h` 当库链接了；或混入了**不同架构**（如 x86_64 vs aarch64）的目标文件。

---

